---
title: "core dump配置"
subtitle: " "
description: " "
date: 2025-07-25T08:04:40Z
author:      "Wayne"
image: ""
tags:
  [
    "c",
    "gdb",
    "coredump",
    "dump",
    "ulimit",
    "setrlimit",
    "/etc/security/limits.conf",
    "/etc/security/limits.d",
    "limits.conf",
    "/proc",
    "sysctl.conf",
    "sysctl",
  ]
categories: ["Tech"]
---

和 core dump 相关的关键配置项

| 组件 / 配置项                    | 用途                                          |
| -------------------------------- | --------------------------------------------- |
| `ulimit -c`                      | 控制是否允许进程生成 core 文件                |
| `/proc/sys/kernel/core_pattern`  | 控制 core 文件的保存路径或是否被程序接管      |
| `/proc/sys/kernel/core_uses_pid` | 控制 core 文件名是否加上进程 PID              |
| `/etc/security/limits.conf`      | 控制登录用户的 core 文件限制（永久设置）      |
| `/etc/sysctl.conf`               | 设置 `core_pattern` 等内核参数（永久）        |
| `/etc/systemd/coredump.conf`     | 控制 systemd-coredump 的行为（Ubuntu 20.04+） |
| `/etc/default/apport`            | Ubuntu 的 apport 故障报告工具开关             |

# core dump 使能控制开关

## 配置 core dump 直接落盘

### 方法 1：

```bash
ulimit -c unlimted      # 这个命令只是设置控制当前shell中启动的子进程core文件的限制，关闭当前shell后即失效
ulimit -c               # 查看当前设置
```

这只会使执行这个命令的当前 shell 实例有效，新打开 shell 中无效。

**WHY** 子进程会继承`ulimit -c unlimted` 设置？(或者 ulimit 本质上修改的是什么？是通过环境变量在父子进程之间继承的方式吗？)
`ulimit` 实际上是 shell 内建命令，它修改的是当前 shell 进程的资源限制（resource limits），这些限制在内核中是通过 `setrlimit()` 系统调用设置的。

```c
int setrlimit(int resource, const struct rlimit *rlim);

/*
也就是修改了如下这一项：RLIMIT_CORE  // 控制 core 文件最大允许生成的大小（单位：字节）
*/
```

ulimit -c unlimited 等价于：把当前进程（即 shell）中的 RLIMIT_CORE 设置为 RLIM_INFINITY（无限制）

为什么 shell 的子进程也继承了这个设置？
这就涉及到 Unix 进程继承模型：在 Linux/Unix 中，子进程通过 `fork()` 继承父进程的资源，包括：

- 环境变量（但 ulimit 不靠这个）

- 文件描述符

- 当前工作目录

- 资源限制（setrlimit）

- umask 等

所以：一旦你在 shell 中设置了 `ulimit -c unlimited`，后面启动的任何子进程都会继承这个设置，自然也就可以生成 core dump 了。

### 方法 2：

将`ulimit -c unlimted`添加到用户的`~/.bashrc 或 ~/.bash_profile`文件中，对当前用户每一个新打开的 bash 终端都会有设置效果。

### 方法 3：

通过 _/etc/security/limits.conf_ 或 _/etc/security/limits.d_
设置用户级别的 core 文件生成限制（对 login shell 生效）：

```conf
* soft core unlimited
* hard core unlimited
```

注意：你需要确保 PAM 加载了 pam_limits.so：

```bash
grep pam_limits.so /etc/pam.d/common-session
```

如果没加，limits.conf 还需要添加：

```conf
session required pam_limits.so
```

这种方法永远有效，OS 重启也 OK.

{{<rawhtml>}}<span style="color:red;">/etc/security/limits.conf 修改了还需要重启吗？</span>{{</rawhtml>}}
不需要重启系统，但需要重新登录用户（或者重启对应服务）才能让配置生效。/etc/security/limits.conf 是由 PAM（Pluggable Authentication Modules）模块在用户登录时读取和应用的配置文件。

也就是说，它的配置只有在：

- 用户重新登录（如重新 ssh 进入）

- 用户打开一个新 shell（比如图形终端重新登录）

- 后台服务（如 systemd）重新启动

时才会被应用。
所以正确做法是：
修改完 /etc/security/limits.conf 后：
不需要重启整个系统

**你可以选择以下任一操作来让设置生效：**

- 当前用户重新登录（例如重新 ssh 连接）

- 如果是图形界面，注销再登录

- 对于 systemd 服务：对于后台服务（如 systemd）来说，limits.conf 并不生效，应使用 systemd 的配置：
  ```ini
  # /etc/systemd/system/your-service.service
  [Service]
  LimitCORE=infinity
  ```
  然后执行：
  ```bash
  sudo systemctl daemon-reexec
  sudo systemctl restart your-service
  ```

## 通过 | 开头（管道符） 被 Apport 或 systemd 等三方程序接管分析处理

### systemd-coredump

_/etc/systemd/coredump.conf_ 是 `systemd` 提供的一个配置文件，用于控制 **systemd-coredump** 服务如何处理 Linux 系统中的 core dump（崩溃转储）文件。

当启用了 systemd 的系统（如 CentOS 7+/Debian/Ubuntu 等）中进程崩溃时, 如果 kernel.core_pattern 设置为以 | 开头（管道符）：

```bash
kernel.core_pattern = |/lib/systemd/systemd-coredump
```

那么系统不会把 core 文件直接写入磁盘，而是交由 systemd-coredump 处理。

_/etc/systemd/coredump.conf_ 这个配置文件控制 systemd-coredump 的行为（如启用压缩、限制大小、路径）：

```bash
[Storage]

# none | external | journal | both

Storage=external

[Coredump]
Compress=no
MaxUse=1G
```

修改后执行：

```bash
sudo systemctl daemon-reexec
```

### abrt-hook-ccpp

![alt text](/img/image-34.png)

### Apport

![alt text](/img/image-35.png)

### systemd-coredump abrt-hook-ccpp Apport 区别

TODO

# core_pattern

`/proc/sys/kernel/core_pattern`可以设置或查看当前 core 文件的生成文件名命名格式及生成路径。

```bash
cat /proc/sys/kernel/core_pattern
```

## 设置 core_pattern

### 方法 1：临时设置，重启失效

```bash
echo "/var/core/core.%e.%p.%t" > /proc/sys/kernel/core_pattern # 这是临时的，OS系统重启后就会恢复默认。
```

### 方法 2：永久生效方法

为了让这个设置在系统每次启动后都自动生效，你就需要把它写进 _/etc/sysctl.conf_ 或 _/etc/sysctl.d/\*.conf_ 。

```bash
sudo vim /etc/sysctl.conf

# 添加这一行（或修改已有的）：
kernel.core_pattern = /var/core/core.%e.%p.%t

# 然后保存并应用：
sudo sysctl -p # 或 sysctl --system
```

Note:

- _sysctl -p_：仅加载一个文件，默认是 /etc/sysctl.conf
- _sysctl --system_：加载多个目录和文件，包括 /etc/sysctl.d/\_.conf 和/etc/sysctl.conf，是现代系统推荐的做法。

## 各占位符含义如下：

| 占位符 | 含义                               | 示例值           |
| ------ | ---------------------------------- | ---------------- |
| `%e`   | 崩溃的程序名（executable name）    | `myapp`          |
| `%p`   | 崩溃的进程 PID（Process ID）       | `12345`          |
| `%t`   | 崩溃时的时间戳（Unix 时间戳，秒）  | `1721880740`     |
| `%u`   | 用户 UID（user ID）                | `1000`           |
| `%g`   | 用户 GID（group ID）               | `1000`           |
| `%s`   | 崩溃信号编号（如 SIGSEGV = 11）    | `11`             |
| `%c`   | 崩溃线程的 TID（线程 ID）          | `12345`          |
| `%h`   | 主机名                             | `ubuntu-host`    |
| `%P`   | 父进程的 PID                       | `345`            |
| `%E`   | 崩溃进程对应的可执行文件的绝对路径 | `/usr/bin/myapp` |
| `%%`   | 字面上的 `%` 符号                  | `%`              |

## demos

如果你想让 core 文件生成在进程当前的工作目录（也就是程序运行时的 cwd 目录），**将 core_pattern 设置为一个相对路径或不带目录的文件名**：

```bash
echo "core.%e.%p.%t" | sudo tee /proc/sys/kernel/core_pattern
```

这样，每个进程崩溃时，core 文件会生成在它当前的工作目录（即 getcwd() 返回的目录）下。


