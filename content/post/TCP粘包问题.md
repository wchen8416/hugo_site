---
title: "TCP的粘包拆包问题"
subtitle: ""
description: "TCP粘包是指发送方发送的若干包数据在接收方接收时粘成一包。这种情况的出现，会导致数据接收解析的混乱，使得应用层难以正确解析数据。"
date: 2025-01-01T13:55:55Z
author:      "Wayne"
image: ""
tags: ["TCP粘包"]
categories: ["Tech"]
---

## TCP 的基本特性

- 面向字节流：TCP 不关心应用层数据的边界，数据被看作一个连续的字节流。
- 可靠传输：通过序列号、确认应答、重传机制等保证数据的可靠性和顺序性。
- 流量控制与拥塞控制：通过调整传输速率防止网络拥堵和接收方溢出。

由于这些特性，TCP 在传输数据时不会保留应用层的消息边界，这直接导致了粘包和拆包的问题。

## 粘包

粘包其实可以从两个角度看：

1. 从发送方的角度看：
   粘包是指应用层发送的多个独立的消息 PDUs 在传输过程中被合并(TCP 协议自身的机制)为一个 TCP segment 到达接收方(也就是一个 TCP segment 里面可能装进去了多个 PDU)，接收方收到这个 segment 后 无法区分这里面是仅有一个还是有多个 PDU。(多个应用层消息 PDU 粘成一个 TCP 数据包发送给接收方。 One TCP segment contains multiple PDUs.)
2. 从接收方的角度看：
   同一条 TCP 连接上消息发送方发送的多个 PDU 都被接收方有序缓存在同一个接收缓存中(如一个大数组)，尽管在这个接收缓存中是按照一个 PDU 字节块 挨着一个 PDU 字节块有序存放的，但从需要解析 PDU 的接收方的视角来看所有的 PDU 依然都粘在一起了，变成了一个整体(大字节数组)。这会使得接收方一脸懵逼，如果没有和发送方提前商定好协议消息格式用以拆包(找到接收缓存中的 PDUs 之间的分割标志)。

尽管可以从两个角度看粘包问题，但其实对发送方的影响不大，因为即使传输过程中粘包了，发送方也完成了自己的职责，因为发送方的主要目的是把数据可靠正确地传给接收方，至于粘不粘包，对发送方来说我都完成了自己的义务工作。 
但对于接收方来说，如果不能正确拆分自己接收缓存中的大字节数组,理解这个大二进制数据数组所传达表示的信息，get 到有效信息，那么它接收的这一堆数据就是垃圾，没有任何意义。接收完全正确，但却完全不理解数据传达的涵义。

TCP 粘包问题发生的本质原因是 TCP/IP 协议栈设计的特点引入的。任何事情都有两面性，想利用 TCP 的可靠高效传输特性，就得花额外的心思去解决它固有的粘包拆包问题。但 TCP 提供的可靠传输特性的好处远远大于它带来的粘包问题的麻烦，想想一下，如果没有发明 TCP 可靠传输机制，程序员得自己实现一套可靠的传输协议，那工作量之大，复杂度之高，简直不堪设想。但解决TCP粘包问题，只需要在应用层协议消息格式上做一些约定(如HTTP消息格式定义或MySql消息格式定义)就可以搞定TCP粘包问题，这很简单相对于自己设计一个TCP传输机制的工作来说。

发生的原因：

1. 发送方发送数据过快：应用层多次小数据发送，TCP 将它们合并为一个大包发送，以提高传输效率。Nagle 算法：为了减少小包的数量，Nagle 算法会将多个小数据包合并为一个包发送。
2. 网络延迟和缓冲：TCP 的发送缓冲区和接收缓冲区会暂存数据，当缓冲区积累到一定程度或达到发送窗口时，才会一次性发送。

## 拆包

将接收方接收缓存中的一堆字节码拆分提炼还原成多个应用层消息/PDU 供应用层使用。

- 靠长度：  
  如设计每一个 PDU 都有一个固定 size 的 header,header 中包含该 PDU payload 的长度信息。接收方根据这个长度字段来判断整个 PDU 的 totalSize(header 固定 size+payload length)，然后根据这个 totalSize 从接收缓存中读取出第一个对应长度的 PDU，同理取出第二个 PDU，以此类推。如 Mysql 协议  
   ![Alt text](/img/mysql-protocol.png)

- 靠分隔符:  
  如 http 协议，在 PDU 之间加上特定的分隔符（如回车换行符），接收方根据这个分隔符来拆分数据。

## UDP 为什么没有粘包拆包问题？

因为 UDP 是基于报文的，每个 UDP 数据包都是一个独立的消息，有固定的长度界限。
