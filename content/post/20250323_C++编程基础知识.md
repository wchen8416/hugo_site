---
title: "C/C++编程基础知识"
subtitle: " "
description: " "
date: 2025-03-23T06:03:25Z
author:      "Wayne"
image: ""
tags:
  [
    "C/C++",
    "namespace",
    "global namespace",
    "namespace pollution",
    "global scope",
    "Unnamed Namespaces",
    "file static",
    "static",
    "scope",
    "Best Practices",
    "extern",
    "const",
    "constexpr",
    "extern const",
    "指针和引用",
    "空指针",
    "NULL",
    "nullptr",
    "stack",
    "heap",
  ]
categories: ["Tech"]
---

# pointer and lvalue reference in C++(C++中的指针和引用)

## reference:

A reference defines an alternative name for an object. A reference type “refers to” another type.  
examples:

```cpp
int ival = 1024;
int &refVal = ival; // refVal refers to (is another name for) ival
int &refVal2; // error: a reference must be initialized
```

Ordinarily, when we initialize a variable, the value of the initializer is copied into the
object we are creating. When we define a reference, **instead of copying the initializer’s
value, we bind the reference to its initializer**. Once initialized, a reference remains
bound to its initial object. There is no way to rebind a reference to refer to a different
object. **Because there is no way to rebind a reference, references must be initialized**.

{{<rawhtml>}}<span style="color:red;">A Reference Is an Alias:</span>{{</rawhtml>}}

A reference is not an object. Instead, a reference is just another name for an already existing object.
After a reference has been defined, all operations on that reference are actually operations on the object to which the reference is bound.
When we assign to a reference, we are assigning to the object to which the reference is bound. When we fetch the value of a reference, we are really fetching the value of the object to which the reference is bound. Similarly, when we use a reference as an initializer, we are really using the object to which the reference is bound.

Because references are not objects, we may not define a reference to a reference. a reference **may be bound only to an object**, not to a literal or to the result of a more general expression.

## pointer:

A pointer is a compound type that “points to” another type. Like references, pointers
are used for indirect access to other objects.

Unlike a reference, a pointer is an object in its own right. Pointers can be assigned and copied; a single pointer can point to several different objects over its lifetime. Unlike a reference, a pointer need not be initialized at the time it is defined. Like other built-in types, pointers defined at block scope have undefined value if they are not initialized.

## difference between reference and pointer:

引用和指针是 C++中两种重要的间接访问机制。引用实质上是一个别名，它在声明时必须初始化，一旦绑定就不能改变。引用不能为空，也不能建立引用的引用，这使得它比指针更安全。**引用在内存中实际上是作为一个常量指针实现的，但它对程序员隐藏了指针的复杂性。**

指针则是一个变量，它存储了另一个变量的内存地址。指针可以为空，可以改变它所指向的对象，也可以进行指针运算。指针的灵活性使它成为一个强大的工具，但同时也容易导致程序错误，如悬空指针和内存泄漏。

Both pointers and references give indirect access to other objects. However, there are
important differences in how they do so. **The most important is that a reference is not
an object.** Once we have defined a reference, there is no way to make that reference
refer to a different object. When we use a reference, we always get the object to
which the reference was initially bound. --- 《C++ Primer, 5th Edition, 2.3.2》

# (void\*)0/0/NULL/nullptr(C++的四种空指针初始化方法及其区别)

在 C/C++ 中，NULL、0、nullptr 和 (void\*)0 都与空指针相关，但它们的使用场景和语义有所不同。以下是它们的区别：

## 四种初始化为空指针的方式

```cpp
int *p1 = nullptr; // equivalent to int *p1 = 0;
int *p2 = 0; // directly initializes p2 from the literal constant 0
// must #include cstdlib
int *p3 = NULL; // equivalent to int *p3 = 0;
int *p4 = (void*)0; // explicitly casts 0 to a void pointer type, then assigns it to p4
```

## NULL 和 0 及 (void\*)0 的关系和区别:

- 在 C 中，NULL 通常定义为 (void\*)0，表示一个空指针。
- 在 C++ 中，NULL 通常定义为 0，表示一个整数常量。

_stddef.h_ 看到完整的这段代码

```c
#undef NULL
#if defined(__cplusplus)
#define NULL 0
#else
#define NULL ((void *)0)
#endif
```

**由于 NULL 可能是整数或指针类型，因此在 C++ 中可能会导致重载函数的歧义。** 看下面例子：

```cpp
//test.cpp
#include<iostream>
using namespace std;
void test(void *p)
{
    cout<<"p is pointer "<<p<<endl;
}
void test(int num)
{
    cout<<"num is int "<<num<<endl;
}
int main(void)
{
    test(NULL);
    return 0;
}
```

编译运行结果：

```shell
$ g++ -o test test.cpp
main.cpp: In function ‘int main()’:
main.cpp:16:14: error: call of overloaded ‘test(NULL)’ is ambiguous test(NULL);
```

很不幸，编译报错了，提示我们有二义性，按照《重载函数匹配规则》，两个都可以匹配，因此最终报错。

## nullptr

但是如果我们使用 `nullptr` 就不会出现上面问题

```cpp
test(nullptr);
```

The most direct approach is to initialize the pointer using the literal `nullptr`, which was introduced by the new standard. nullptr is a literal that has a special type that can be converted to any other pointer type.

#### NULL VS nullptr

Older programs sometimes use a _preprocessor variable_ named `NULL`, which the _cstdlib_ header defines as 0.  
**Preprocessor variables** are managed by the _preprocessor_, and are not part of the _std_
namespace. As a result, we refer to them directly without the _std::_ prefix.  
When we use a preprocessor variable, the preprocessor automatically replaces the variable by its value. {{<rawhtml>}}<span style="color:blue;">Hence, initializing a pointer to NULL is equivalent to initializing it to 0.</span>{{</rawhtml>}} **ModernC++ programs generally should avoid using NULL and use nullptr instead.**

## Conclusion

在 C++ 中，尽量使用 `nullptr` 而不是 `NULL`，因为 `nullptr` 可以明确区分指针和整数，避免歧义。

## reference:

1. https://mp.weixin.qq.com/s/en0ythvTwH4eodPaYToj9Q

# c++中的 extern const 语法涵义

TODO

# Namespaces(C++命名空间)

Namespaces provide a much more controlled mechanism `for preventing name collisions`. Namespaces partition the global namespace. A namespace is a scope. By
defining a library’s names inside a namespace, library authors (and users) can avoid the limitations inherent in global names.

**Namespace pollution 命名空间污染问题：**

Large programs tend to use independently developed libraries. Such libraries also tend
to define a large number of {{<rawhtml>}}<span style="color:red;">global</span>{{</rawhtml>}} names, such as classes, functions, and templates.
When an application uses libraries from many different vendors, it is almost inevitable
that some of these names will clash. {{<rawhtml>}}<strong>Libraries that put names into the <span style="color:red;">global
namespace</span> are said to cause <span style="color:red;">namespace pollution</span>.</strong>{{</rawhtml>}}

**C 语言是通过给全局变量或函数添加前缀来解决命名空间污染(命名碰撞)问题:**

Traditionally, programmers avoided namespace pollution **by using very long names for the global entities they defined**. Those names often contained a prefix indicating which library defined the name. This solution is far from ideal: It can be cumbersome for programmers to write and read programs that use such long names.  
C 语言通过给全局变量或函数添加前缀来解决命名空间污染问题的方法导致全局函数名字和全局变量名字过长，不方便阅读或程序员引用。C 语言的这种通过给名字添加前缀来解决全局命名碰撞冲突的问题比起 C++的命名空间机制显得笨拙,渣渣。

## c++ 的 Namespaces 的几种使用形式

- The Global Namespace(全局命名空间)  
  Names defined at {{<rawhtml>}}<span style="color:red;">global scope</span>{{</rawhtml>}} (i.e., names declared outside any class, function, or
  namespace) are defined inside the global namespace. The global namespace is
  implicitly declared and exists in every program. Each file that defines entities at global
  scope (implicitly) adds those names to the global namespace.  
  `::member_name`: refers to a member of the global namespace.

- Nested Namespace(嵌套命名空间)  
  Names declared in an inner namespace hide declarations of the same name in an outer namespace.
  Names defined inside a nested namespace are local to that inner namespace. Code in the outer parts of the enclosing namespace may refer to a name in a nested namespace only through its qualified name.

- Unnamed Namespaces(匿名命名空间)  
  An unnamed namespace is the keyword namespace followed immediately by a block of declarations delimited by curly braces. {{<rawhtml>}}<span style="color:red;">Variables defined in an unnamed namespace have static lifetime: They are created before their first use and destroyed when the program ends(类似 C 语言局部静态变量).</span>{{</rawhtml>}}</br>

  {{<rawhtml>}}<span style="color:red;">An unnamed namespace may be discontiguous within a given file but does not span files.</span>{{</rawhtml>}} Each file has its own unnamed namespace. If two files contain unnamed namespaces, those namespaces are unrelated. {{<rawhtml>}}<span style=" text-decoration: underline;">Both unnamed namespaces can define the same name; those definitions would refer to different entities. If a header defines an unnamed namespace, the names in that namespace define different entities local to each file that includes the header.</span>{{</rawhtml>}}

## Using Namespace Members in C++(访问或使/引用 Namespace 内成员的方法)：

程序员使用 namespace 中的成员有三种方式：

- using Namespace Aliases  
  命名空间别名主要是为了简化或短化比较长的命名空间名字，方便引用,也能简化源代码。类似 C 的`#typedef` 所表达的意思或`#define` 的作用。
- using Declarations  
  命名空间声明**只能精确引入命名空间的某个具体成员**，而不是整个命名空间的所有成员。 类似 C 语言的 `extern int gVar;` 所表达的意思。和软件工程的最小权限原则相呼应。
- using Directives  
  命名空间指示符则是直接引入整个命名空间的所有成员，类似于 C 语言的`#include` 所表达的意思。

#### Using Namespace Aliases(通过命名空间别名访问命名空间成员)

A namespace alias can be used to associate a shorter synonym with a long namespace name. For example, a long namespace name such as

```cpp
namespace cplusplus_primer { /* ... */ };
namespace primer = cplusplus_primer;
```

A namespace alias can also refer to a nested namespace:

```cpp
namespace Qlib = cplusplus_primer::QueryLib;
Qlib::Query q;
```

简而言之，命名空间别名主要是简化过长的命名空间名字，便于程序员简化源代码。和 C 语言的`#typedef` 功能类似。

#### Using Namespace Declarations(使用命名空间声明的方式来导入命名空间的特定成员名字的方式)

A using declaration lets us use a name from a namespace without qualifying the name with a namespace_name:: prefix.

A using declaration has the form:

```cpp
using namespace::name;
using std::cin;
```

使用命名空间声明时的注意点：

1. **A Separate using Declaration Is Required for Each Name。**  
   一个 using declaration 语句只能引入一个名字，如果要引入多个名字，则需要多次使用 using declaration。A using declaration introduces **only one** namespace member at a time. It allows us to **be very specific regarding which names are used in our programs**.
2. **Headers Should Not Include using Declarations。**  
   The reason is that the contents of a header are copied into the including program’s text. If a header has a using declaration, then every program that includes that header gets that same using declaration. As a result, a program that didn’t intend to use the specified library name might encounter unexpected name conflicts.

#### Using Namespace Directives(使用命名空间指示符导入命名空间全部成员名字的方式)

like a using declaration, allows us to use the unqualified form of
a namespace name. **BUT** unlike a using declaration, we retain no control over which names are made visible—**they all are**. 当使用 using directive 的时候，我们无法控制该命名空间中的哪些(哪一部分)成员的名字是可见的，它们全部(该命名空间的所有成员的名字)都是可见的,要么引入整个命名空间的所有成员，要么就是不引入任何东西。所以如果只想引入一部分命名空间成员，则应该使用 using declaration。

**The scope of names introduced by a using directive(通过 using directive 引入的成员名字的作用域(或可见)范围?)：**

it has the effect of lifting the namespace members into **the nearest scope that contains both the namespace itself and the using directive**.
也就是，using directive 引入的命名空间成员的名字的作用域范围是同时包含该 using directive 语句和该命名空间本身的那个最近的那个作用域 scope。

example ONE:

```cpp
// namespace A and function f are defined at global scope
namespace A {
 int i, j;
}
void f()
{
 using namespace A; // injects the names from A into the global scope
 cout << i * j << endl; // uses i and j from namespace A
 // ...
}
```

example TWO:

```cpp
namespace blip {
    int i = 16, j = 15, k = 23;
    // other declarations
}

int j = 0; // ok: j inside blip is hidden inside a namespace
void manip()
{
 // using directive; the names in blip are ''added'' to the global scope
 using namespace blip; // clash between ::j and blip::j
 // detected only if j is used
 ++i; // sets blip::i to 17
 ++j; // error ambiguous: global j or blip::j?
 ++::j; // ok: sets global j to 1
 ++blip::j; // ok: sets blip::j to 16
 int k = 97; // local k hides blip::k
 ++k; // sets local k to 98
}
```

When a namespace is injected into an enclosing scope, it is possible for names in the namespace to conflict with other names defined in that (enclosing) scope. For example, inside manip, the blip member j conflicts with the global object named j. **Such conflicts are permitted, but to use the name, we must explicitly indicate which version is wanted. Any unqualified use of j within manip is ambiguous.**

Because the names are in different scopes, **local declarations within manip may hide some of the namespace member names**. The local variable k hides the namespace member blip::k. Referring to k within manip is not ambiguous; it refers to the local variable k.

## Argument-Dependent Lookup and Parameters of Class Type

当调用一个函数时，如果该函数的参数是类类型(class type)，编译器会自动去参数类被定义的命名空间中查找函数名，同时可以省略掉该函数名前的明确的命名空间声明。如当对标准输入流对象 std::cin 使用 >> 运算符(函数)时，编译器会自动去命名空间 `std` 中查找该函数名>>的定义，且可以直接使用>>，不用像这样`std::operator>>(std::cin, s);`还需要明确指定命名空间麻烦。

Consider the following simple program:

```cpp
std::string s;
std::cin >> s;
```

As we know, this call is equivalent to

```cpp
operator>>(std::cin, s);
```

This operator>> function is defined by the string library, which in turn is defined in the `std` namespace. {{<rawhtml>}}<span style="color:red;">Yet(But) we can we call operator>> without an std:: qualifier and without a using declaration. WHY?</span>{{</rawhtml>}}
We can **directly access** the output operator>> without using std declare(即 std::operator>>) {{<rawhtml>}}<span style="color:red;">because</span>{{</rawhtml>}} When we pass an object of a class type to a function, the compiler searches the namespace in which the argument’s class is defined in addition to the normal scope lookup. This exception also applies for calls that pass pointers or references to a class type.

In this example, when the compiler sees the “call” to operator>>, it looks for a matching function in the current scope, including the scopes enclosing the output statement. In addition, because the >> expression has parameters of class type, the compiler also looks in the namespace(s) in which the types of cin and s are defined. Thus, for this call, the compiler looks in the std namespace, which defines the
istream and string types. When it searches std, the compiler finds the string output operator function.

This exception in the **lookup rules(函数名字搜索规则)** allows nonmember functions that are conceptually part of the interface to a class to **be used without requiring a separate using declaration**.

In the absence of this exception to the lookup rules, either we would have to provide an appropriate using declaration for the output operator:

```cpp
using std::operator>>; // needed to allow cin >> s
```

or we would have to use the function-call notation in order to include the namespace qualifer:

```cpp
std::operator>>(std::cin, s); // ok: explicitly use std::>>
```

So either of these declarations is awkward and would make simple uses of the IO library more complicated.

## Overloading and Namespaces

TODO

## Best Practices/Warnings(命名空间使用过程中的最佳实践/约定习成的习惯/警告)

#### Do not put a #include inside the namespace. [Warning]

不要将`#include` 放到 namespace 中，否者该头文件中定义的所有全局变量/全局函数或命名空间都属于该 namespace 的成员(member)了。

It is worth noting that ordinarily, {{<rawhtml>}}<span style="color:red;">we do not put a #include inside the namespace.
If we did, we would be attempting to define all the names in that header as members of the enclosing namespace.</span>{{</rawhtml>}}

```cpp
// ---- Sales_data.h----
// #includes should appear before opening the namespace
#include <string>
namespace cplusplus_primer {
    class Sales_data { /* ... */};
    Sales_data operator+(const Sales_data&, const Sales_data&);
    // declarations for the remaining functions in the Sales_data interface
}
```

For example, if our Sales_data.h file opened the cplusplus_primer before including the string header our program would be in
error. {{<rawhtml>}}<span style="color:blue;">It would be attempting to define the `std` namespace nested inside cplusplus_primer.</span>{{</rawhtml>}}

#### Namespaces that define multiple, unrelated types should use separate files to represent each type. [Best Practice]

因为命名空间有这个特性(Namespaces Can Be Discontiguous)，所以我们可以利用这个 the feature of namespace 将同一个 namespace 下的不怎么相关的一些 types 或 classes 放到不同的文件中分开定义，这样模块性更强，代码更清晰。

#### Unnamed Namespaces Replace File Statics. [Best Practice]

使用匿名命名空间代替 file statics(这是 C 语言的习惯或功能，在 C++程序中使用这个 C 语言的语法不是最佳的)。

Prior to the introduction of namespaces, programs declared names as **_static_** to make them local to a file. The use of **_file statics_** is inherited from C.  
In C, a global entity declared static is invisible outside the file in which it is declared.
The use of file static declarations is deprecated by the C++ standard. {{<rawhtml>}}<span style="color:red;">File statics should be avoided and unnamed namespaces used instead.</span>{{</rawhtml>}}  
Names defined in an unnamed namespace are in the same scope as the scope at which the namespace is defined. If an unnamed namespace is defined at the outermost scope in the file, then names in the unnamed namespace must differ from names defined at global scope:

```cpp
int i; // global declaration for i
namespace {
 int i;
}
// ambiguous: defined globally and in an unnested, unnamed namespace
i = 10;
```

所以在 C++代码中，要避免使用 file statics(这是 C 程序的玩意)，而应该养成使用 unnamed namespaces(这是 C++带来的高级玩意) 来代替的习惯。

#### Rather than relying on a `using directive`, it is better to use a `using declaration` for each namespace name used in the program. [Best Practice]

因为使用 using directive 会把整个命名空间的所有名字都导入/注入进来，这会导致命名冲突的可能性增加。所以最好使用 using declaration 精确导入 来代替 using directive 全部导入。

Doing so reduces the number of names injected into the namespace. Ambiguity errors caused by using declarations are detected at the point of declaration, not use, and so are easier to find and fix.

#### Header files should not contain `using directives` or `using declarations`. [Warning]

A header that has a using directive or declaration at its top-level scope **injects names into every file that includes the header**. Ordinarily, headers should define only the names that are part of its interface, not names used in its own implementation. As a result, header files should not contain using directives or using declarations

# C++ Literals(C++字面量类型)

介绍 c++中的各种字面量的类型. 例如整数,浮点数,字符和字符串的字面量类型. 以及如何通过后缀来改变它们的类型.

A value, such as 42, is known as a literal because its value self-evident.  
{{<rawhtml>}}<span style="color:red;">Every literal has a type.</span>{{< /rawhtml>}} {{<rawhtml>}}<span style="color:blue;">The form and value of a literal determine its type.</span>{{< /rawhtml>}}

#### Integer Literals

20 /_ decimal _/ 024 /_ octal _/ 0x14 /_ hexadecimal _/

The type of an integer literal depends on its value and notation. {{<rawhtml>}}<span style="color:red;">By default, decimal literals are signed whereas octal and hexadecimal literals can be either signed or unsigned types.</span>{{< /rawhtml>}} A decimal literal has **the smallest type** of int, long, or long long (i.e., the first type in this list) in which the literal’s value **fits**. Octal and hexadecimal literals have the smallest type of int, unsigned int, long, unsigned long, long long, or unsigned long long in which the literal’s value fits. {{<rawhtml>}}<span style="color:red;font-weight:bold;">It is an error to use a literal that is too large to fit in the largest related type.</span>{{< /rawhtml>}} There are no literals of type short. We’ll see in Table 2.2 (p. 40) that we can **override these defaults by using a suffix**.

Integer Literals Suffixes:

| Suffix   | Minimum Type |
| :------- | :----------- |
| u or U   | unsigned     |
| l or L   | long         |
| ll or LL | long long    |

We can independently specify the signedness and size of an integral literal. If the suffix contains a U, then the literal has an unsigned type, so a decimal, octal, or hexadecimal literal with a U suffix has the smallest type of unsigned int, unsigned long, or unsigned long long in which the literal’s value fits. If the suffix contains an L, then the literal’s type will be at least long; if the suffix contains LL, then the literal’s type will be either long long or unsigned long long. We can combine U with either L or LL. For example, a literal with a suffix of UL will be either unsigned long or unsigned long long, depending on whether its value fits in unsigned long.

#### negative number

Although integer literals may be stored in signed types, technically speaking, the value of a decimal literal is never a negative number. If we write what appears to be a negative decimal literal, for example, -42, **the minus sign is not part of the literal**. The minus sign **is an operator** that negates the value of its (literal) operand.

#### Floating-Point Literals

Floating-Point Literals Suffixes:

| Suffix | Type        |
| :----- | :---------- |
| f or F | float       |
| l or L | long double |

#### Character and Character String Literals

A character enclosed within single quotes is a literal of type **char**. Zero or more characters enclosed in double quotation marks is a **string literal**:

```cpp
'a' // character literal
"Hello World!" // string literal
```

**Two string literals that appear adjacent to one another and that are separated only
by spaces, tabs, or newlines are concatenated into a single literal.** We use this form of
literal when we need to write a literal that would otherwise be too large to fit
comfortably on a single line:

```cpp
// multiline string literal
std::cout << "a really, really long string literal "
                "that spans two lines" << std::endl; // ok: equivalent to one string literal
```

Character and Character String Literals Prefixes:

| Prefix | Type         |
| :----- | :----------- |
| u      | char16_t     |
| U      | char32_t     |
| L      | wchar_t      |
| u8     | char (UTF-8) |

#### Boolean Literals

The words `true` and `false` are literals of type bool:

```cpp
bool b = true;
```

#### Pointer Literals

The word `nullptr` is a pointer literal.  
The most direct approach is to initialize pointer using the literal `nullptr`, which was
introduced by the new standard.  
**`nullptr` is a literal that has a special type that can be converted to any other pointer type.**

#### Specifying the Type of a Literal

We can override the default type of an integer, floating- point, or character literal **by
supplying a suffix or prefix**.

```cpp
L'a' // wide character literal, type is wchar_t
u8"hi!" // utf-8 string literal (utf-8 encodes a Unicode character in 8 bits)
42ULL // unsigned integer literal, type is unsigned long long
1E-3F // single-precision floating-point literal, type is float
3.14159L // extended-precision floating-point literal, type is long double
```

#### Refereces

1. [C++ Primer, edition 5th, Stroustrup, 2013, chapter 2.1.3]

# Heap and Stack(C/C++编程中的堆和栈)

## stack 和 heap 在内存中的分配有何区别？

栈内存的分配和释放是由编译器自动完成的。当变量超出其作用域时，栈内存会自动释放。栈内存的分配和释放速度很快，因为它使用简单的指针移动来实现。栈内存的大小是固定的，在程序运行时就已确定。

堆内存则是动态分配的，由程序员手动管理或使用智能指针等工具管理。堆内存的生命周期不受作用域限制，可以在需要时分配，在不需要时释放。堆内存的大小理论上只受系统可用内存的限制。但堆内存的分配和释放相对较慢，且容易产生内存碎片。

## malloc/free 和 new/delete

TODO

## malloc, calloc, realloc

####
